from SteinerTripleSystem import *
from copy import deepcopy
from itertools import product

'''
    Difficult instances for the STS isomorphism problem
    k: exponent
    returns: A STS of size n=2**k-1 and every cycle switch of length 4
'''
def pg2k_sts(k):
    n = 2 ** k - 1
    B = set()
    for i in range(1, n // 2 + 1):
        for j in range(i + 1, n):
            B.add(tuple(sorted([i - 1, j - 1, i.__xor__(j) - 1])))
    return SteinerTripleSystem(n, list(sorted(B)))


'''
'''
def str_sts_decomp(TC, output = None):
    import string
    str0Z = '0123456789' + string.ascii_uppercase
    str_cycles = {}
    for k in sorted(TC.keys()):
        str_cycles[k] = []
        for c in (TC[k]):
            str_c = map(lambda t: '{}{}{}'.format(str0Z[t[0]],str0Z[t[1]],str0Z[t[2]]), map(sorted, c))
            str_cycle = str_c[0]
            for i in range(1, len(str_c)):
                str_cycle = str_cycle + '--{}--{}'.format((set(str_c[i-1]) & set(str_c[i])).pop(), str_c[i])
            str_cycles[k].append(str_cycle)
    if output== None:
        return str_cycles
    else:
        wf = open(output, 'w')
        for k in sorted(str_cycles.keys()):
            wf.write('{}: \t{}\n'.format(k, str_cycles[k]))
        wf.flush()
        wf.close()

def cycle_vector(S):
    Cij = {}
    n = S.order
    for i in range(n):
        for j in range(i + 1, n):
            Gij = S.cycle_graph(i, j)
            key = tuple(sorted(map(len, Gij)))
            if key in Cij.keys():
                Cij[key] += 1
            else:
                Cij[key] = 1
    return Cij



def sum_pk(alpha, beta, p):
    q = 1
    s = 0
    while alpha > 0 or beta > 0:
        s += q * ((-alpha - beta) % p)
        q *= p
        alpha = alpha // p
        beta = beta // p
    return s

'''
All systes from affine are of size 3**k
'''
def affine_sts(k):
    S = set()
    n = 3**k
    for i in range(n):
        for j in range(i+1, n):
            s = frozenset([i,j,sum_pk(i, j, 3)])
            S.add(s)
    S = sorted(list(map(sorted, S)))
    S = SteinerTripleSystem(n, S)
    return S


def algebraic_hts(k, base = None, Lambda = None):
    if base is None:
        base = []
        for i in range(k):
            base.append([0]*k)
            base[i][i] = 1
    if Lambda is None:
        Lambda = {(1,2,3): 1}

    # Get a representation for x and y
    base = base[::-1]
    space = [[0,1,2]]*k
    cart = list(product(*space))
    T = set()
    for i in range(len(cart)):
        alpha = cart[i]
        x = np.sum(np.dot(a, e) for (a, e) in zip(alpha, base))
        x3 = np.sum([x[l] * 3 ** l for l in range(k)])
        for j in range(i+1, len(cart)):
            beta = cart[j]
            y = np.sum(np.dot(b, e) for (b, e) in zip(beta, base))
            # Compute z (Example 28.2, need of general case)
            c1 = alpha[0] - beta[0]
            c2 = alpha[1] * beta[2] - alpha[2]*beta[1]
            c = c1 * c2 % 3
            ce0 = np.mod(np.dot(c, base[-1]), 3)
            z = np.mod(-x - y + ce0, 3)
            y3 = np.sum([y[l] * 3 ** l for l in range(k)])
            z3 = np.sum([z[l] * 3**l for l in range(k)])
            T.add(tuple(sorted([x3, y3, z3])))
    return SteinerTripleSystem(3**k, list(sorted(T)))

def get_block_with_pair(T, pair):
    t = list(filter(lambda t: pair[0] in t and pair[1] in t, T))
    if len(t) > 0:
        return tuple(sorted(t[0]))
    return None

'''
Get sub-system generated by P
'''
def generate_subsystem(S, P):
    Y = set()
    for t in P:
        Y = Y.union(t)
    lastY = set()
    while lastY != Y:
        pairs = combinations(Y, 2)
        lastY = set(Y)
        for pair in pairs:
            Y.add(operate(S, pair))
    pairs = combinations(Y, 2)
    T = set()
    for pair in pairs:
        T.add(get_block_with_pair(S, pair))
    T = list(sorted(T))
    return SteinerTripleSystem(len(Y), T)

'''
'''
def operate(T, pair):
    t = get_block_with_pair(T, pair)
    if t is None:
        print('Not found: {}', pair)
    else:
        t = list(t)
    if t:
        t.remove(pair[0]), t.remove(pair[1])
        return t[0]
    return None

'''
'''
def trade(S, P1, P2):
    T = deepcopy(S.T)
    for t in P1:
        T.remove(t)
    for t in P2:
        T.append(t)
    return SteinerTripleSystem(S.order, T)


'''
from itertools import combinations
S = pg2k_sts(6)

T1 = generate_subsystem(S.T, [S.T[0], S.T[1], S.T[3], S.T[10]])
for (i,j,k,l) in combinations(range(S.order), 4):
    T2 = generate_subsystem(S.T, [S.T[i], S.T[j], S.T[k], S.T[l]])
    IT = list(filter(lambda B: B in T2.T, T1.T))
    print(len(IT))'''